#include "vrtos.h"
#include "queue_mgr.h"
#include "tim.h"

/******************************************************************************* 

                App Message Management Module

*******************************************************************************/

static app_timer_list_t *          app_timer_list;                     /**<  */

/*
** Message function definition
*/
uint32_t app_msg_callback( void **msg_sll, void * msg_node ) {
    if ( NULL == msg_sll || NULL == msg_node ) {
        return FALSE;
    }
    
    MOUNT( *msg_sll, msg_node );
    
    return TRUE;
}

p_msg_handler_t app_msg_create( uint32_t msg_type, p_msg_data_t p_msg_data, uint32_t length ) {
    msg_node_t * msg = ( msg_node_t * )xmalloc( MSG_SIZE );
    if ( NULL != msg ) {
        msg->length = length;
        msg->type = msg_type;
        if ( ( length > 0 ) && ( NULL != p_msg_data ) ) {
            msg->data = ( p_msg_data_t )xmalloc( length );
            if ( NULL != msg->data ) {
                memcpy( msg->data, p_msg_data, length );
            }
        } else {
            msg->data = NULL;
            msg->next = NULL;
        }
//        LOG( "create msg sonsume mem %d.\r\n", MSG_SIZE );
    }
    return ( p_msg_handler_t )msg;
}

/*
** Post a message to task.
** If post_delay_ticks = 0 (N) means post the meassage immdiately otherwise post 
** after N ticks by create a timer.
*/
uint32_t app_msg_post( p_task_handler_t task_handler, p_msg_handler_t msg_node ) {
    task_cb_t *p_task = ( task_cb_t * )task_handler;
    
    if ( NULL == msg_node || NULL == p_task) {
        return FALSE;
    }
    
    // Post message immdiately.
    MOUNT( p_task->p_msg_handler, msg_node );
    p_task->state = TASK_STATE_RUN;
    
    return TRUE;
}

/*
** Post a message after specified delay ticks by set a timer.
** param    ticks_periodic_interval
**          If a message needs to be sent periodically, this value should be set.
** param    ticks_first_delay
**          The delay before first sending.
** param    mode
**          Timer mode. APP_TIMER_MODE_SINGLE_SHOT or APP_TIMER_MODE_REPEATED
** param    task_handler.
**          App task handler. Generated by function task_create(...)
** param    msg_node
**          Message sent to the specified task.
** retval   TRUE or FALSE.
*/
uint32_t app_msg_post_timer( uint32_t           ticks_periodic_interval,
                             uint32_t           ticks_first_delay,
                             app_timer_mode_t   mode,
                             p_task_handler_t   task_handler,
                             p_msg_handler_t    msg_node) {
    task_cb_t *p_task = ( task_cb_t * )task_handler;
    
    if ( NULL == msg_node || NULL == p_task) {
        return FALSE;
    }
    
    /*
    ** Post message after delay ticks.
    */
    p_timer_handler_t p_timer = app_timer_create( ticks_periodic_interval,            
                                                  ticks_first_delay,                           
                                                  mode,  
                                                  p_task,            
                                                  msg_node );
    if ( NULL == p_timer ) {
        LOG("msg create timer mem error.\r\n");
        return FALSE;
    }
    p_task->state = TASK_STATE_PEND;
//    MOUNT( p_task->p_msg_handler, msg_node );
    
    return TRUE;
}

/*
** Copy a message
*/
p_msg_handler_t app_msg_copy( msg_node_t * msg_node ) {
    msg_node_t *p_new = NULL;
    
    if ( NULL != msg_node ) {
        p_new = ( msg_node_t * )xmalloc( MSG_SIZE );
        if ( NULL != p_new ) {
            if ( msg_node->length > 0 ) {
                memcpy( p_new->data, msg_node->data, msg_node->length );
            }
            p_new->length = msg_node->length;
            p_new->type = msg_node->type;
            p_new->next = NULL;
        }
    }
    return p_new;
}

uint32_t app_timer_msg_delete ( msg_node_t *msg_node ) {
    msg_node_t *p = msg_node;
    if ( NULL != p ) {
        if ( NULL != p->data ) {
            xfree( p->data );
        }
        xfree( p );
        return TRUE;
    }
    return FALSE;
}

/*
** Delete a message node
**
** param    msg_handler
**          Pointer to app message handler.
** param    msg_node
**          Need to delete the message node.
**
** retval   TRUE or FALSE.
*/
uint32_t app_task_msg_delete( p_msg_handler_t *msg_handler, msg_node_t *msg_node ) {   //
    msg_node_t **p = ( msg_node_t ** )msg_handler;
    
    if ( ( NULL != *p ) && ( NULL != msg_node ) ) {
        
        // Remove frome message link list.
        UNMOUNT( *p, msg_node );
        
        // Free message data memory
        if ( NULL != msg_node->data ) {
            xfree( msg_node->data );
        }
        
        // Free message structure memory.
        xfree( msg_node );
//        LOG("delete msg free mem %d.\r\n", sizeof( msg_node_t ));
        return TRUE;
    }
    return FALSE;
}

uint32_t app_msg_flush( p_msg_handler_t msg_handler ) {
    msg_node_t * current;
    msg_node_t * p = ( msg_node_t * )msg_handler;
    
    if ( NULL == msg_handler ) {
        return FALSE;
    }
    
    while ( NULL != ( current = p->next ) ) {
        p->next = current->next;
        
        // Remove from message link list.
        UNMOUNT( msg_handler, current );
        
        // Free message memory.
        if ( NULL != current->data ) {
            xfree( current->data );
            xfree( current );
        } else {
            // Meet fault
            break;
        }
    }
    return TRUE;
}

/*
** Waiting message.
** If there is no new message return NULL otherwise return a pointer of message.
*/
msg_node_t *app_msg_pend( p_msg_handler_t msg_handler ) {
    msg_node_t * p = ( msg_node_t * )msg_handler;
    
    if ( NULL == p ) {
        return NULL;
    } else {
        return p->next;
    }
}

/******************************************************************************* 

                App Task Management Module

*******************************************************************************/
static task_cb_t *sys_task_handler;

void app_task_init( void ) {
    sys_task_handler->callback = NULL;
    sys_task_handler->func_name = NULL;
    sys_task_handler->next = NULL;
    sys_task_handler->priority = 0;
    sys_task_handler->p_msg_handler = NULL;
}

/*
** 
*/
uint32_t task_insert( task_cb_t **task_handler, task_cb_t *insert_node ) {
    task_cb_t **p = ( task_cb_t ** )task_handler;
    task_cb_t *current;
    
    /*
    ** Allocate memory to new node and save the new value. Return FALSE if malloc
    ** error otherwise return TRUE.
    */
//    task_cb_t *new_node = ( task_cb_t * )xmalloc( sizeof( task_cb_t ) );
//    if ( NULL == new_node ) {
//        return FALSE;
//    }
//    new_node->priority      = insert_node->priority;
//    new_node->callback      = insert_node->callback;
//    new_node->p_msg_handler = insert_node->p_msg_handler;
//    new_node->next          = insert_node->next;
//    new_node->func_name     = insert_node->func_name;
    if ( NULL == insert_node )
        return FALSE;
    /*
    ** Find the inserted node by node id until it less than the current node. 
    */
    if ( NULL == (*p) ) {
        MOUNT( p, insert_node );
    } else {
        while ( NULL != ( current = (*p)->next ) && current->priority < insert_node->priority ) {
            (*p)->next = current->next;
        }
        
        /*
        ** Insert a new node in the list and return TRUE.
        */
        insert_node->next = current;
        (*p)->next  = insert_node;
    }
    return TRUE;
}

uint32_t task_delete( p_task_handler_t task_handler, task_cb_t *del_node ) {
    task_cb_t *current;
    task_cb_t *p = ( task_cb_t * )task_handler;
    
    if ( NULL == p ) {
        return FALSE;
    }
    
    /*
    ** Find the deleted node by function address and free the node memory.
    */
    while ( NULL != ( current = p->next ) && ( current->callback == del_node->callback ) ) {
        p->next = current->next;
    }
    
    if (NULL != current) {
        UNMOUNT( p, current );
        xfree( current );
        return TRUE;
    }
    return FALSE;
}

/*
** Create a task control block handler.
** 
** param    func_name
**          Function name string.
** param    callback
**          Task callback function.
** param    priority
**          Task priority. 1 to 15.
** param    msg_handler
**          Pointer to task message handler.
** retval   Pointer to task control block handler or NULL.
*/
p_task_handler_t task_create( char *                   func_name,      
                              task_func_callback_t     callback,       
                              uint32_t                 priority,       
                              p_msg_handler_t          msg_handler ) {
     
    if ( NULL == callback ) {
        return NULL;
    }
    
    task_cb_t *task_node = ( task_cb_t * )xmalloc( sizeof( task_cb_t ) );
    if ( NULL != task_node ) {
        task_node->next             = NULL;
        task_node->state            = TASK_STATE_PEND;
        task_node->p_msg_handler    = ( msg_node_t * )msg_handler;
        task_node->priority         = priority;
        task_node->callback         = *callback;
        task_node->func_name        = func_name;
        
        if ( !task_insert( &sys_task_handler, task_node ) ) {
            LOG( "%s task create failed.\r\n", func_name );
            return NULL;
        }
    }
    return ( p_task_handler_t )task_node;
}

void task_dispatch( void ) {
    task_cb_t *current = sys_task_handler;
    msg_node_t *p_msg = NULL;
    
    while ( current ) {
        
        /*
        ** Perform related operations if task message list is not empty.
        */
        if ( ( NULL != ( p_msg = current->p_msg_handler ) ) ) {
            
            /*
            ** Excute current function.
            */
            current->callback( current, p_msg );
        }
        current = current->next;
    }
}

/******************************************************************************* 

                App Timer Management Module

*******************************************************************************/

/*
** Notice: Called this function before the task is created.
*/
void app_timer_init(void) {
    app_timer_list = ( app_timer_list_t * )xmalloc( sizeof( app_timer_list_t ) );
    if ( NULL != app_timer_list ) {
        app_timer_list->next                 = NULL;
        app_timer_list->dynamic_sleep_ticks  = 0;
        app_timer_list->timer_nbr_max        = 0;
        app_timer_list->tick_source          = HAL_GetTick;
        app_timer_list->time_slice           = TIMER_TIME_SLICE;
        app_timer_list->is_runing            = false;
    }
}

void app_timer_start( void ) {
    app_timer_list->is_runing = true;
    HAL_TIM_Base_Start_IT(&htim11);
}

void app_timer_stop( void ) {
    app_timer_list->is_runing = false;
    HAL_TIM_Base_Stop_IT(&htim11);
}

/*
** Notice
** ticks_periodic_interval and ticks_first_delay must be a multiple of TIMER_TIME_SLICE, 
** otherwise timer would not be created and return NULL.
**
** param    ticks_periodic_interval
**          If a message needs to be sent periodically, this value should be set.
** param    ticks_first_delay
**          The delay before first sending.
** param    mode
**          Timer mode. APP_TIMER_MODE_SINGLE_SHOT or APP_TIMER_MODE_REPEATED
** param    task_handler.
**          App task handler. Generated by function task_create(...)
** param    msg_node
**          Message sent to the specified task.
**
** retval   NULL or Pointer to timer handler.
*/
p_timer_handler_t app_timer_create( uint32_t            ticks_periodic_interval,   \
                                    uint32_t            ticks_first_delay,         \
                                    app_timer_mode_t    mode,                      \
                                    p_task_handler_t    p_task_handler,            \
                                    p_msg_handler_t     p_msg_handler) {
    app_timer_list_t *pheader = app_timer_list;
    if ( ( 0 == ticks_periodic_interval ) || \
         ( 0 != ( ticks_periodic_interval % TIMER_TIME_SLICE ) ) || \
         ( 0 != ( ticks_first_delay % TIMER_TIME_SLICE ) ) ) {
        return NULL;
    }
    
    p_app_timer_t htimer = ( p_app_timer_t )xmalloc( sizeof( app_timer_t ) );
    if ( NULL != htimer ) {
        htimer->next                    = NULL;
        htimer->mode                    = mode;
        htimer->p_msg_node              = ( msg_node_t * )p_msg_handler;
        htimer->p_task_handler          = ( task_cb_t * )p_task_handler;
        htimer->ticks_at_start          = app_timer_list->tick_source();
        htimer->ticks_to_expire         = 0;
        htimer->ticks_first_delay       = ticks_first_delay;
        htimer->ticks_periodic_interval = ticks_periodic_interval;
        
        pheader->timer_nbr_max++;
        MOUNT( pheader->next, htimer );
//        LOG( "create timer consume mem %d...%d\r\n", sizeof( app_timer_t ), pheader->timer_nbr_max );
    } else {
        LOG("create timer mem error.\r\n");
    }
    
    return ( p_timer_handler_t )htimer;
}

/*
** Delete a timer node.
**
** param    timer_node.
**          Need to delete the timer node.
**
** retval   TRUE or FALSE.
*/
uint32_t app_timer_delete( app_timer_t *timer_node ) {
    app_timer_list_t *pheader = app_timer_list;
    app_timer_t *current = pheader->next;
    
    while ( ( NULL != current ) && ( current != timer_node ) ) {
        current = current->next;
    }
    
    if ( timer_node ) {
        UNMOUNT( pheader->next, timer_node );
        xfree( timer_node );
        if ( pheader->timer_nbr_max > 0 )
            pheader->timer_nbr_max--;
//        LOG( "delete timer release mem %d...%d\r\n", sizeof( app_timer_t ), pheader->timer_nbr_max );
        return TRUE;
    }
    return FALSE;
}

p_timer_handler_t app_timer_find( p_timer_handler_t timer ) {
    p_timer_handler_t current = app_timer_list->next;
    
    while( NULL != current ) {
        if ( timer == current ) {
            break;
        }
    }
    
    return current;
}

/*
** Set timer paramters of task.
*/
p_timer_handler_t app_task_timer_set( uint32_t                      ticks_periodic_interval,
                                      uint32_t                      ticks_first_delay,
                                      app_timer_mode_t              mode,
                                      p_timer_timeout_handler_t     timeout_handler,
                                      p_task_handler_t              app_task,
                                      p_msg_handler_t               msg_handler ) {
    
    return NULL;
}

/*
** Function for computing the difference between two timer counter values.
** return   Number of ticks elapsed from ticks_old to ticks_now.
*/
uint32_t app_timer_get_diff_ticks( uint32_t lastest_ticks, uint32_t old_ticks ) {
    uint32_t ticks_diff = 0;
    
    ticks_diff = ( lastest_ticks - old_ticks ) & TIMER_MAX_TICK_COUNTER;
    
    return ticks_diff;
}

/*
** Calculate the processing of all timer times as well as the timeout callback function.
**
** param    None.
**
** retval   None
*/
void app_timer_timeouts_check( void ) {
    app_timer_list_t *pheader = app_timer_list;
    app_timer_t *current = pheader->next;
    
    if ( pheader->is_runing ) {
        while ( current && ( pheader->timer_nbr_max > 0 )) {
            
            // Timer first delay check.
            if ( 0 == current->ticks_first_delay ) {
                current->ticks_to_expire += pheader->time_slice;
                
                // If app timer ticks expired and excute timeout handler.
                if ( current->ticks_to_expire >= current->ticks_periodic_interval ) {
                    current->ticks_to_expire = 0;
                    current->ticks_at_start = pheader->tick_source();
                    
                    p_msg_handler_t c_msg = app_msg_copy( current->p_msg_node );
                    if ( NULL != c_msg ) {  
                        MOUNT( current->p_task_handler->p_msg_handler, c_msg );
                        current->p_task_handler->state = TASK_STATE_RUN;
                    }
                    
                    current->p_task_handler->state = TASK_STATE_RUN;
                    
                    // If app timer is not repeat mode than delete it.
                    if ( APP_TIMER_MODE_SINGLE_SHOT == current->mode ) {
                        app_timer_msg_delete( current->p_msg_node );
                        app_timer_delete( current );
                    }
                }
            } else {
                current->ticks_first_delay -= pheader->time_slice;
            }
            
            // Calculate the ticks to run the next task.
            // Could perform low-power sleep if the time to meet the requirements.
            if ( 0 == pheader->dynamic_sleep_ticks ) {
                pheader->dynamic_sleep_ticks = app_timer_get_diff_ticks( current->next->ticks_periodic_interval,
                                                                       current->next->ticks_to_expire);
            }
            current = current->next;
        }
        
        #if LOW_POWER_ENABLE
        // System ready to into sleep.
        if ( pheader->dynamic_sleep_ticks >= SYSTEM_IDLE_TICKS_BEFORE_SLEEP ) {
            // add your code ...
        }
        #endif
    }
}

